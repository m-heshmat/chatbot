import os
from typing import List
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
import uvicorn
from agents.langchain_agent import VulnAgent
from prompts.prompts import SYSTEM_PROMPT_MULTI, SYSTEM_PROMPT_FROM_SEARCH
from schemas.pydantic_schemas import VulnerabilityList, Vulnerability
from tools.websearch import search_results_for_vuln
from langchain.output_parsers import PydanticOutputParser
from langchain_openai.chat_models import ChatOpenAI
from dotenv import load_dotenv
from pathlib import Path

# Load environment variables
load_dotenv(dotenv_path=Path(__file__).resolve().parent.parent / ".env")

def get_env_var(name: str, default: str = None, required: bool = False):
    value = os.getenv(name, default)
    if required and value is None:
        raise ValueError(f"Missing required environment variable: {name}")
    return value

# Config
API_KEY = get_env_var("API_KEY", required=True)
MODEL = get_env_var("MODEL", required=True)
BASE_URL = get_env_var("BASE_URL", required=True)
TEMPERATURE = float(get_env_var("TEMPERATURE", default="0.6"))

# FastAPI app
app = FastAPI(title="Vulnerability Analyzer")

class VulnerabilityInput(BaseModel):
    vulnerabilities: List[str]

# Original Agent for LLM-based vuln extraction
agent = VulnAgent(
    api_key=API_KEY,
    model=MODEL,
    system_prompt=SYSTEM_PROMPT_MULTI,
    pydantic_class=VulnerabilityList,
    base_url=BASE_URL,
    temperature=TEMPERATURE
)

@app.post("/vulns_details")
async def vulns_details(data: VulnerabilityInput):
    try:
        structured_data, _ = agent.get_vulns_details(data.vulnerabilities)

        final_results = []
        for i, vuln_input in enumerate(data.vulnerabilities):
            try:
                vuln_info = structured_data.vulnerabilities[i]
                analysis = {
                    "description": vuln_info.description,
                    "remediation": vuln_info.remediation,
                    "severity": vuln_info.severity,
                    "category": vuln_info.category,
                    
                }

                search_query = f"{vuln_input} vulnerability exploit remediation"
                search_results = search_results_for_vuln(search_query)

                final_results.append({
                    "vulnerability": vuln_input,
                    "analysis": analysis,
                    "search_results": search_results
                })

            except IndexError:
                continue

        return {"results": final_results}

    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error processing vulnerabilities: {str(e)}")

@app.post("/vulns_from_search")
async def vulns_from_search(data: VulnerabilityInput):
    try:
        final_results = []

        for vuln_input in data.vulnerabilities:
            search_results = search_results_for_vuln(vuln_input)
            if not search_results:
                final_results.append({"error": "No search results found for: " + vuln_input})
                continue

            # Use the first search result's snippet and link if available
            link = search_results[0].get("link") if search_results else None
            snippet = search_results[0].get("snippet") if search_results else None

            search_context = f"Snippet: {snippet}\nLink: {link}" if snippet or link else ""

            prompt = SYSTEM_PROMPT_FROM_SEARCH + f"\n\nContext:\n{search_context}\n\nRespond with structured JSON only."

            llm = ChatOpenAI(model=MODEL, base_url=BASE_URL, api_key=API_KEY, temperature=TEMPERATURE)
            parser = PydanticOutputParser(pydantic_object=Vulnerability)
            schema_hint = parser.get_format_instructions()
            full_prompt = f"{prompt}\n\nSchema format:\n{schema_hint}\n\nOutput (as JSON):```json"

            response = llm.invoke(full_prompt)
            parsed = parser.parse(str(response.content))
            analysis = parsed.model_dump()
            # Move snippet and link to top-level, remove search_results and vulnerability fields
            if link:
                analysis["link"] = link
            if snippet:
                analysis["snippet"] = snippet

            final_results.append(analysis)

        return {"results": final_results}

    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error processing: {str(e)}")

if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=7777)
